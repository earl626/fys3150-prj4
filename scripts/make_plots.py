
import os
import numpy as np
import matplotlib.pyplot as plt

# =======================================================================================
#             First we plot the observables vs T for different MC cycles
#                        and compare to analytical results
# =======================================================================================

#
# Get path to the input files
#

# This prefix must match the one you use when calling run_main
file_name_prefix = "analytical_vs_num"

folder_path = "output/"
if not os.path.isdir(folder_path):
    folder_path = "../" + folder_path

while not os.path.isdir(folder_path):
    folder_path = input("Please enter the path to the folder containing the input files: ")

#
# Find all CSV files generated by the C++ code
#

files = [f for f in os.listdir(folder_path)
         if f.startswith(file_name_prefix) and f.endswith(".csv")]

if not files:
    raise RuntimeError(f"No files starting with '{file_name_prefix}' found in '{folder_path}'")

#
# Sort files by MC cycles (suffix after last underscore, before .csv)
#

def extract_cycles(filename):
    base = os.path.splitext(filename)[0]
    suffix = base.split("_")[-1]
    try:
        return int(suffix)
    except ValueError:
        return int(1e18)

files.sort(key=extract_cycles)

# 
# Load all files
#

data_per_cycles = []  # list of (cycles, data_array)

for fname in files:
    full_path = os.path.join(folder_path, fname)
    data = np.loadtxt(full_path, delimiter=",", skiprows=1)
    cycles = extract_cycles(fname)
    data_per_cycles.append((cycles, data))

# Use the T grid from the first file (they should all share the same T)
T = data_per_cycles[0][1][:, 0]

# 
# Create figure with 4 subplots
#

fig, axes = plt.subplots(2, 2, figsize=(10, 8))
ax_eps, ax_m, ax_Cv, ax_chi = axes.flatten()

#
# Plot each cycles set
#

for cycles, data in data_per_cycles:
    eps_MC        = data[:, 1]
    eps_analytic  = data[:, 2]
    abs_m_MC      = data[:, 4]
    abs_m_analytic= data[:, 5]
    Cv_MC         = data[:, 7]
    Cv_analytic   = data[:, 8]
    chi_MC        = data[:, 9]
    chi_analytic  = data[:, 10]

    label_cycles = f"MC, {cycles} cycles"

    # --- Energy per spin ---
    ax_eps.plot(T, eps_MC, lw=1.8, linestyle="-", label=label_cycles)

    # --- |m| per spin ---
    ax_m.plot(T, abs_m_MC, lw=1.8, linestyle="-", label=label_cycles)

    # --- Heat capacity per spin ---
    ax_Cv.plot(T, Cv_MC, lw=1.8, linestyle="-", label=label_cycles)

    # --- Susceptibility per spin ---
    ax_chi.plot(T, chi_MC, lw=1.8, linestyle="-", label=label_cycles)

# Plotting analytic curves
ax_eps.plot(T, eps_analytic, lw=2.0, linestyle="--", label="analytic")
ax_m.plot(T, abs_m_analytic, lw=2.0, linestyle="--", label="analytic")
ax_Cv.plot(T, Cv_analytic, lw=2.0, linestyle="--", label="analytic")
ax_chi.plot(T, chi_analytic, lw=2.0, linestyle="--", label="analytic")
        
#
# Beautify plots
#

ax_eps.set_xlabel(r"$T\ [J/k_B]$")
ax_eps.set_ylabel(r"$\langle \epsilon \rangle\ [J]$")
ax_eps.set_title("Energy per spin")
ax_eps.grid(True)
ax_eps.legend()

ax_m.set_xlabel(r"$T\ [J/k_B]$")
ax_m.set_ylabel(r"$\langle |m| \rangle$")
ax_m.set_title("Magnetisation per spin")
ax_m.grid(True)
ax_m.legend()

ax_Cv.set_xlabel(r"$T\ [J/k_B]$")
ax_Cv.set_ylabel(r"$C_V / N\ [k_B]$")
ax_Cv.set_title("Heat capacity per spin")
ax_Cv.grid(True)
ax_Cv.legend()

ax_chi.set_xlabel(r"$T\ [J/k_B]$")
ax_chi.set_ylabel(r"$\chi / N\ [1/J]$")
ax_chi.set_title("Susceptibility per spin")
ax_chi.grid(True)
ax_chi.legend()

plt.tight_layout()

output_name = os.path.join(folder_path, file_name_prefix + "_observables.pdf")
plt.savefig(output_name)
plt.show()

#
# PLOT 2: Relative errors vs T (ε and |m|)
#

fig2, (ax_re_eps, ax_re_m) = plt.subplots(1, 2, figsize=(12, 4))

for cycles, data in data_per_cycles:
    rel_eps = data[:, 3]
    rel_m   = data[:, 6]

    label_cycles = f"{cycles} cycles"

    ax_re_eps.plot(T, rel_eps, lw=1.8, label=label_cycles)
    ax_re_m.plot(T, rel_m,   lw=1.8, label=label_cycles)

# Beautify error plots
ax_re_eps.set_xlabel(r"$T\ [J/k_B]$")
ax_re_eps.set_ylabel(r"Relative error in $\langle \epsilon \rangle$")
ax_re_eps.set_title("Relative error of energy per spin")
ax_re_eps.set_yscale("log")
ax_re_eps.grid(True)
ax_re_eps.legend()

ax_re_m.set_xlabel(r"$T\ [J/k_B]$")
ax_re_m.set_ylabel(r"Relative error in $\langle |m| \rangle$")
ax_re_m.set_title("Relative error of magnetisation")
ax_re_m.set_yscale("log")
ax_re_m.grid(True)
ax_re_m.legend()

plt.tight_layout()

output_name = os.path.join(folder_path, file_name_prefix + "_rel_error.pdf")
plt.savefig(output_name)
plt.show()

# =======================================================================================
#                             Now we plot the burnin study
# =======================================================================================

# This prefix must match the one you use when calling run_main
file_name_prefix = "burnin_study"

#
# Find all CSV files generated by the C++ code
#

files = [f for f in os.listdir(folder_path)
         if f.startswith(file_name_prefix) and f.endswith(".csv")]

if not files:
    raise RuntimeError(f"No files starting with '{file_name_prefix}' found in '{folder_path}'")

# Separate ordered and unordered files
ordered_files   = [f for f in files if "_ordered_" in f]
unordered_files = [f for f in files if "_unordered_" in f]

if not ordered_files:
    raise RuntimeError("No ordered burn-in file found.")
if not unordered_files:
    raise RuntimeError("No unordered burn-in file found.")

# Take the first match
burnin_file_ordered   = ordered_files[0]
burnin_file_unordered = unordered_files[0]

burnin_path_ordered   = os.path.join(folder_path, burnin_file_ordered)
burnin_path_unordered = os.path.join(folder_path, burnin_file_unordered)

if not (os.path.isfile(burnin_path_ordered) and os.path.isfile(burnin_path_unordered)):
    print("Burn-in study CSV files not found in", folder_path)

#
# Load data: columns are [T, cycle, eps, mean_eps]
#

burnin_ordered   = np.loadtxt(burnin_path_ordered,   delimiter=",", skiprows=1)
burnin_unordered = np.loadtxt(burnin_path_unordered, delimiter=",", skiprows=1)

def select_temperature(data, T_target, tol=1e-8):
    """
    Extract (cycle, eps, mean_eps) for a given temperature T_target.
    Rows are filtered on |T - T_target| < tol and sorted by cycle.
    """
    mask = np.abs(data[:, 0] - T_target) < tol
    if not np.any(mask):
        raise RuntimeError(f"No rows with T={T_target} found in burn-in data")
    sub = data[mask]
    # sort by cycle
    idx = np.argsort(sub[:, 1])
    sub = sub[idx]
    cycles   = sub[:, 1]
    eps      = sub[:, 2]
    mean_eps = sub[:, 3]
    return cycles, eps, mean_eps

# Extract data for T = 1.0 and T = 2.4, ordered and unordered
cycles_T10_o, eps_T10_o, mean_eps_T10_o = select_temperature(burnin_ordered,   1.0)
cycles_T24_o, eps_T24_o, mean_eps_T24_o = select_temperature(burnin_ordered,   2.4)
cycles_T10_u, eps_T10_u, mean_eps_T10_u = select_temperature(burnin_unordered, 1.0)
cycles_T24_u, eps_T24_u, mean_eps_T24_u = select_temperature(burnin_unordered, 2.4)

# Same cycles for all curves
n_MC_cycles = cycles_T10_u

#
# Plot current energy eps (thin, transparent) and running mean <eps> (thick)
# for T=1.0 and T=2.4, ordered and unordered initial states.
#

fig3, ax_burnin = plt.subplots(figsize=(10, 6))

ax_burnin.plot(n_MC_cycles, eps_T10_u, '-', color='#377eb8', alpha=0.4, linewidth=1.0)
ax_burnin.plot(n_MC_cycles, eps_T10_o, '-', color='#4daf4a', alpha=0.4, linewidth=1.0)
ax_burnin.plot(n_MC_cycles, eps_T24_u, '-', color='#e41a1c', alpha=0.4, linewidth=1.0)
ax_burnin.plot(n_MC_cycles, eps_T24_o, '-', color='#984ea3', alpha=0.4, linewidth=1.0)

ax_burnin.plot(n_MC_cycles, mean_eps_T10_u, '-', linewidth=2.0, color='#377eb8',
               label=r'$T=1.0$ $J/k_{B}$, unordered')
ax_burnin.plot(n_MC_cycles, mean_eps_T10_o, '-', linewidth=2.0, color='#4daf4a',
               label=r'$T=1.0$ $J/k_{B}$, ordered')
ax_burnin.plot(n_MC_cycles, mean_eps_T24_u, '-', linewidth=2.0, color='#e41a1c',
               label=r'$T=2.4$ $J/k_{B}$, unordered')
ax_burnin.plot(n_MC_cycles, mean_eps_T24_o, '-', linewidth=2.0, color='#984ea3',
               label=r'$T=2.4$ $J/k_{B}$, ordered')
# --- end snippet ---

ax_burnin.set_xscale("log")
ax_burnin.set_xlabel("Number of Monte Carlo cycles")
ax_burnin.set_ylabel(r"Energy per spin $\epsilon$, $\langle \epsilon \rangle$")
ax_burnin.set_title(r"Burn-in study for $L=20$")
ax_burnin.grid(True)
ax_burnin.legend()

plt.tight_layout()

burnin_output_name = os.path.join(folder_path, "burnin_study_eps_vs_cycles.pdf")
plt.savefig(burnin_output_name)
plt.show()

# =======================================================================================
#                             energy histograms
# =======================================================================================

# This prefix must match the one you use when calling run_main
file_name_prefix = "energy_distribution"

#
# Find all CSV files generated by the C++ code
#

files = [f for f in os.listdir(folder_path)
         if f.startswith(file_name_prefix) and f.endswith(".csv")]

if not files:
    raise RuntimeError(f"No files starting with '{file_name_prefix}' found in '{folder_path}'")

# Take the first match
energy_file = files[0]
energy_path = os.path.join(folder_path, energy_file)

if not os.path.isfile(energy_path):
    print("Energy distribution CSV file not found in", folder_path)

#
# Load data: columns are [T, cycle, eps, mean_eps]
#

energy_data = np.loadtxt(energy_path, delimiter=",", skiprows=1)

def select_eps_samples(data, T_target, tol=1e-8):
    """
    Extract all epsilon samples for a given temperature T_target.
    Rows are filtered on |T - T_target| < tol.
    Returns a numpy array of eps values.
    """
    mask = np.abs(data[:, 0] - T_target) < tol
    if not np.any(mask):
        raise RuntimeError(f"No epsilon samples found for T={T_target} in energy distribution data")
    eps = data[mask, 2]  # column 2 = eps
    return np.array(eps)

# Extract epsilon samples for T = 1.0 and T = 2.4
eps_T10 = select_eps_samples(energy_data, 1.0)
eps_T24 = select_eps_samples(energy_data, 2.4)

#
# Print basic statistics (mean and variance) for discussion in the report
#

def print_statistics(eps_arr, T):
    mean_eps = eps_arr.mean()
    var_eps  = eps_arr.var(ddof=1)
    print(f"T = {T:.1f}: <eps> = {mean_eps:.6f}, Var(eps) = {var_eps:.6e}, N_samples = {eps_arr.size}")

print("\nPrinting statistics for the histograms:\n")
print_statistics(eps_T10, 1.0)
print_statistics(eps_T24, 2.4)

#
# Build normalised histograms p_epsilon(epsilon; T)
#

# Use a common range so the two histograms are directly comparable
global_min = min(eps_T10.min(), eps_T24.min())
global_max = max(eps_T10.max(), eps_T24.max())

n_bins = 50  # adjust if you want finer / coarser bins

#
# Plot normalised histograms for T = 1.0 and T = 2.4
#

fig4, (ax_T10, ax_T24) = plt.subplots(1, 2, figsize=(10, 4))

# --- Histogram for T = 1.0 ---
ax_T10.hist(eps_T10,
            bins=n_bins,
            range=(global_min, global_max),
            density=True,
            histtype="step",
            linewidth=1.8)

ax_T10.set_xlabel(r"Energy per spin $\epsilon\ [J]$")
ax_T10.set_ylabel(r"Probability density $p_{\epsilon}(\epsilon; T)$")
ax_T10.set_title(r"Energy distribution, $L=20$, $T=1.0\,J/k_B$")
ax_T10.grid(True)

# --- Histogram for T = 2.4 ---
ax_T24.hist(eps_T24,
            bins=n_bins,
            range=(global_min, global_max),
            density=True,
            histtype="step",
            linewidth=1.8)

ax_T24.set_xlabel(r"Energy per spin $\epsilon\ [J]$")
ax_T24.set_ylabel(r"Probability density $p_{\epsilon}(\epsilon; T)$")
ax_T24.set_title(r"Energy distribution, $L=20$, $T=2.4\,J/k_B$")
ax_T24.grid(True)

plt.tight_layout()

hist_output_name = os.path.join(folder_path,
                                file_name_prefix + "_eps_histograms_L20.pdf")
plt.savefig(hist_output_name)
plt.show()

# =======================================================================================
#                           Phase transition study
#        Plots <eps>, <|m|>, C_V/N and phi/N vs T for different lattice sizes L
# =======================================================================================

file_name_prefix = "phase_transition_L"

# Find all CSV files for the phase transition study
files = [f for f in os.listdir(folder_path)
         if f.startswith(file_name_prefix) and f.endswith(".csv")]

if not files:
    print(f"No CSV files starting with '{file_name_prefix}' found in '{folder_path}'")

# For each L, keep the file with the largest number of MC cycles
# File name pattern: phase_transition_L40_200000.csv
runs_by_L = {}  # L -> (cycles, filename)

for fname in files:
    base = os.path.splitext(fname)[0]
    parts = base.split("_")
    # Expect ... L40 200000 as the last two parts
    if len(parts) < 3:
        continue

    L_part = parts[-2]       # e.g. "L40"
    cycles_part = parts[-1]  # e.g. "200000"

    if not L_part.startswith("L"):
        continue

    try:
        L_val = int(L_part[1:])
        cycles = int(cycles_part)
    except ValueError:
        continue

    prev = runs_by_L.get(L_val)
    if (prev is None) or (cycles > prev[0]):
        runs_by_L[L_val] = (cycles, fname)

if not runs_by_L:
    raise RuntimeError(
        f"No well-formed '{file_name_prefix}*' files found in '{folder_path}'"
    )

# Sort lattice sizes so curves appear in a nice order
sorted_L = sorted(runs_by_L.keys())

fig5, axes = plt.subplots(2, 2, figsize=(10, 8))
ax_eps, ax_m, ax_Cv, ax_chi = axes.flatten()

# Colour palette (same style as earlier: ColorBrewer-like)
color_cycle = ['#377eb8', '#4daf4a', '#e41a1c', '#984ea3',
               '#ff7f00', '#a65628']

# store crude Tc(L) estimates from maxima of C_V/N and χ/N
Tc_from_Cv = {}
Tc_from_chi = {}

for idx, L in enumerate(sorted_L):
    cycles, fname = runs_by_L[L]
    full_path = os.path.join(folder_path, fname)

    data = np.loadtxt(full_path, delimiter=",", skiprows=1)

    # Columns from main.cpp:
    # 0: T
    # 1: eps_MC
    # 4: abs_m_MC
    # 7: Cv_MC
    # 9: chi_MC
    T        = data[:, 0]
    eps_MC   = data[:, 1]
    abs_m_MC = data[:, 4]
    Cv_MC    = data[:, 7]
    chi_MC   = data[:, 9]

    color = color_cycle[idx % len(color_cycle)]
    label = rf"$L={L}$"

    # Energy per spin
    ax_eps.plot(T, eps_MC, '-', lw=1.8, color=color, label=label)

    # |m| per spin
    ax_m.plot(T, abs_m_MC, '-', lw=1.8, color=color, label=label)

    # Heat capacity per spin
    ax_Cv.plot(T, Cv_MC, '-', lw=1.8, color=color, label=label)

    # Susceptibility per spin
    ax_chi.plot(T, chi_MC, '-', lw=1.8, color=color, label=label)

    # Crude estimates of Tc(L) from the position of the peaks
    i_max_Cv = np.argmax(Cv_MC)
    i_max_chi = np.argmax(chi_MC)
    Tc_from_Cv[L] = T[i_max_Cv]
    Tc_from_chi[L] = T[i_max_chi]

#
# Beautify plots (same style as your earlier figures)
#

ax_eps.set_xlabel(r"$T\ [J/k_B]$")
ax_eps.set_ylabel(r"$\langle \epsilon \rangle\ [J]$")
ax_eps.set_title("Energy per spin")
ax_eps.grid(True)
ax_eps.legend()

ax_m.set_xlabel(r"$T\ [J/k_B]$")
ax_m.set_ylabel(r"$\langle |m| \rangle$")
ax_m.set_title("Magnetisation per spin")
ax_m.grid(True)
ax_m.legend()

ax_Cv.set_xlabel(r"$T\ [J/k_B]$")
ax_Cv.set_ylabel(r"$C_V / N\ [k_B]$")
ax_Cv.set_title("Heat capacity per spin")
ax_Cv.grid(True)
ax_Cv.legend()

ax_chi.set_xlabel(r"$T\ [J/k_B]$")
ax_chi.set_ylabel(r"$\chi / N\ [1/J]$")
ax_chi.set_title("Susceptibility per spin")
ax_chi.grid(True)
ax_chi.legend()

plt.tight_layout()

phase_output_name = os.path.join(folder_path,
                                 "phase_transition_observables_vs_T.pdf")
plt.savefig(phase_output_name)
plt.show()

#
# Print Tc(L) estimates
#

print("\nEstimated critical temperatures T_c(L)")
print("from maxima in C_V/N and χ/N:")
print("   L      T_c(C_V)     T_c(χ)")
for L in sorted_L:
    print(f"{L:4d}  {Tc_from_Cv[L]:10.4f}  {Tc_from_chi[L]:10.4f}")

# =======================================================================================
#                           Finite-size scaling of T_c
#            Use T_c(L) from C_V/N and phi/N peaks to estimate T_c(L to infty)
# =======================================================================================

# Convert to arrays, sorted by L
L_vals = np.array(sorted_L, dtype=float)
inv_L  = 1.0 / L_vals

Tc_Cv   = np.array([Tc_from_Cv[L]   for L in sorted_L])
Tc_chi  = np.array([Tc_from_chi[L]  for L in sorted_L])

# Linear fit: T_c(L) = T_c_inf + a/L
coeffs_Cv  = np.polyfit(inv_L, Tc_Cv,  1)
coeffs_chi = np.polyfit(inv_L, Tc_chi, 1)

slope_Cv,  Tc_inf_Cv  = coeffs_Cv   # slope = a, intercept = T_c_inf
slope_chi, Tc_inf_chi = coeffs_chi

# Analytical Onsager result
Tc_exact = 2.0 / np.log(1.0 + np.sqrt(2.0))

print("\n============================================================")
print("Finite-size scaling: T_c(L) = T_c(infty) + a / L")
print("------------------------------------------------------------")
print(f"Using C_V/N peaks:")
print(f"  T_c(infty)\tapprox\t{Tc_inf_Cv:.6f} J/k_B")
print(f"  a\t\tapprox {slope_Cv:.6f}")
print()
print(f"Using phi/N peaks:")
print(f"  T_c(infty)\tapprox\t{Tc_inf_chi:.6f} J/k_B")
print(f"  a\t\tapprox {slope_chi:.6f}")
print()
print(f"Onsager exact result:")
print(f"  T_c(infty) = 2 / ln(1 + sqrt(2)) approx {Tc_exact:.6f} J/k_B")
print("============================================================\n")

#
# Plot T_c(L) vs 1/L with linear fits
#

fig6, ax_Tc = plt.subplots(figsize=(6, 5))

# Use the same ColorBrewer-like palette as elsewhere
color_Cv  = '#377eb8'  # blue
color_chi = '#e41a1c'  # red

# Data points
ax_Tc.plot(inv_L, Tc_Cv,  'o',  markersize=6, label=r'$T_c(L)$ from $C_V/N$',  color=color_Cv)
ax_Tc.plot(inv_L, Tc_chi, 's',  markersize=6, label=r'$T_c(L)$ from $\chi/N$', color=color_chi)

# Lines for the fits, including the L→∞ (1/L = 0) limit
x_fit = np.linspace(0.0, inv_L.max()*1.05, 200)
y_fit_Cv  = slope_Cv  * x_fit + Tc_inf_Cv
y_fit_chi = slope_chi * x_fit + Tc_inf_chi

ax_Tc.plot(x_fit, y_fit_Cv,  '-', linewidth=1.8, color=color_Cv,
           label=rf'Fit $C_V$: $T_c(\infty)={Tc_inf_Cv:.3f}$')
ax_Tc.plot(x_fit, y_fit_chi, '-', linewidth=1.8, color=color_chi,
           label=rf'Fit $\chi$: $T_c(\infty)={Tc_inf_chi:.3f}$')

# Mark the exact Onsager value at 1/L = 0
ax_Tc.axhline(Tc_exact, linestyle='--', linewidth=1.5, color='#4daf4a',
              label=rf'Onsager: $T_c(\infty)={Tc_exact:.3f}$')

ax_Tc.set_xlabel(r"$1/L$")
ax_Tc.set_ylabel(r"$T_c(L)\ [J/k_B]$")
ax_Tc.set_title(r"Finite-size scaling of $T_c(L)$")
ax_Tc.grid(True)
ax_Tc.legend()

plt.tight_layout()

Tc_fss_output_name = os.path.join(folder_path, "Tc_extrapolation_fss.pdf")
plt.savefig(Tc_fss_output_name)
plt.show()
