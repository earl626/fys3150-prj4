
---

# 2D Ising Model â€” FYS3150 Project 4

## ğŸ“– Overview
This repository contains the implementation for **Project 4** in the course *FYS3150 â€” Computational Physics*.  
The project studies the **2D Ising model** on a square lattice using **Markov Chain Monte Carlo** (Metropolis algorithm) to explore temperature-dependent behaviour in ferromagnets and to estimate the **critical temperature** associated with the phase transition.

The code computes thermodynamic observables such as:
- Energy
- Magnetisation
- Heat capacity
- Susceptibility

and uses **finite-size scaling** to extrapolate the critical temperature in the thermodynamic limit.

---

## ğŸ¯ Project Goals
- Implement the 2D Ising model with periodic boundary conditions.
- Use the **Metropolis algorithm** to generate Markov chains of spin configurations.
- Validate the solver using **analytical results** for a \(2 \times 2\) lattice.
- Study:
  - Burn-in behaviour (ordered vs unordered initial states)
  - Energy distributions
  - Temperature dependence of key observables
- Perform **finite-size scaling** to estimate \( T_c(L \to \infty) \).
- Enable optional parallelisation for large simulations.

---

## ğŸ“‚ Repository Structure
```
â”œâ”€â”€ src/                          # C++ source files (implementation)
â”‚   â”œâ”€â”€ main.cpp                  # CLI parsing, simulation orchestration, I/O dispatch
â”‚   â”œâ”€â”€ ising_model.cpp           # Core Ising logic: lattice init, energy/magnetisation, Metropolis updates
â”‚   â””â”€â”€ utils.cpp                 # Implementation of Utility functions
â”œâ”€â”€ include/                      # C++ headers (interfaces)
â”‚   â”œâ”€â”€ ising_model.hpp           # IsingModel class declaration and public API
â”‚   â””â”€â”€ utils.hpp                 # Utility function declarations and types
â”œâ”€â”€ scripts/                      # Analysis and plotting
â”‚   â””â”€â”€ make_plots.py             # Loads CSVs, produces report figures
â”œâ”€â”€ output/                       # Results generated by runs
â”‚   â”œâ”€â”€ *.csv                     # Generated Simulation Data
â”‚   â””â”€â”€ *.pdf                     # Generated Plots
â”œâ”€â”€ build/                        # Compiled executables
â”‚   â””â”€â”€ run_main                  # Executable produced by `make`
â”œâ”€â”€ Makefile                      # Build File
â””â”€â”€ README.md                     # Project documentation (this file)
```

---

## âš™ï¸ Compilation & Dependencies

### Requirements
- **C++17** compiler  
- **GNU Make**  
- Optional: **OpenMP** (for parallelisation)  
- **Python 3** with:
  - `numpy`
  - `matplotlib`

Install Python dependencies:
```bash
pip install numpy matplotlib pandas
```

### Build Instructions
```bash
make main
```

Executable:
```bash
build/run_main
```

---

## â–¶ï¸ Running Simulations
Example on how to we ran our simulations
```bash

export OMP_NUM_THREADS=12

build/run_main analytical_vs_num 2 1.0 3.5 251 1000 2025
build/run_main analytical_vs_num 2 1.0 3.5 251 10000 2026
build/run_main analytical_vs_num 2 1.0 3.5 251 100000 2027

build/run_main burnin_study 20 1.0 2.4 2 100000 2028 --enable-trajectory-mode
build/run_main burnin_study 20 1.0 2.4 2 100000 2029 --enable-trajectory-mode --enable-ordered-initial-state

build/run_main energy_distribution 20 1.0 2.4 2 1000000 42 --set-burnin 50000 --enable-trajectory-mode

#
# Timing
#

export OMP_NUM_THREADS=1
build/run_main timing_dummy 2 1.0 3.5 256 1000000 2025

export OMP_NUM_THREADS=6
build/run_main timing_dummy 2 1.0 3.5 256 1000000 2025

export OMP_NUM_THREADS=12
build/run_main timing_dummy 2 1.0 3.5 256 1000000 2025

#
# Investigating phase transitions
#

export OMP_NUM_THREADS=12

# build/run_main phase_transition_L40 40 2.10 2.40 61 200000 42 --set-burnin 50000
# build/run_main phase_transition_L60 60 2.10 2.40 61 200000 43 --set-burnin 50000
# build/run_main phase_transition_L80 80 2.10 2.40 61 200000 44 --set-burnin 50000
# build/run_main phase_transition_L100 100 2.10 2.40 61 200000 45 --set-burnin 50000

build/run_main phase_transition_L60  60 2.26 2.29 61 1000000 43 --set-burnin 200000
build/run_main phase_transition_L80  80 2.26 2.29 61 1000000 44 --set-burnin 200000
build/run_main phase_transition_L100 100 2.26 2.29 61 1000000 45 --set-burnin 200000
build/run_main phase_transition_L120 120 2.26 2.29 61 800000  46 --set-burnin 160000

```

---

## ğŸ“Š Plotting & Analysis
```bash
python scripts/make_plots.py
```
Produces all figures in `output/`.

---

## ğŸ“œ Results
- Analytical validation: \( T_c(L=2) \) matches exact results.  
- Numerical scaling: \( T_c(L \to \infty) \approx 2.269 \, J/k_B \) (Onsagerâ€™s solution).  
- Burn-in analysis shows faster equilibration from ordered initial states at low \(T\).

---

## ğŸ‘¥ Authors
- **Solveig Juntunen**  
- **Erling Sandbekk**

---

## References
- [Project description and background](https://anderkve.github.io/FYS3150/book/projects/project4.html)
- Course: *FYS3150 â€“ Computational Physics* (University of Oslo)  

---

## TODO

### 1. Profile and Optimise the Metropolis Update Loop
The Metropolis update is the dominant cost in the simulation.  
- Use a profiler to identify bottlenecks  
- Remove redundant calculations  
- Consider inlining or restructuring neighbour-energy checks  

### 2. Refine Memory Layout and Spin Representation
Benchmark different spin storage formats (`int`, `short`, `float`) to evaluate:  
- Cache behaviour  
- Compiler vectorisation  
- Potential speedups  

### 3. Improve Reproducibility and RNG Design
Revisit seed generation for each temperature point and thread.  
- Ensure independent RNG streams when using OpenMP  
- Guarantee fully reproducible runs  

### 4. Decouple Analysis Mode and Trajectory Mode
Currently, the code branches into two I/O styles.  
- Introduce a clearer abstraction  
- Separate output formatting from simulation logic  

### 5. Build Lightweight Unit Tests
Focus on correctness and edge cases:  
- Î”E correctness for random spin patterns  
- Periodic boundary conditions  
- Exact 2Ã—2 analytical values  

These tests protect against subtle mistakes that may arise during optimisation.

### 6. Add support for running multiple independent simulations with different random seeds
Combine results to reduce variance.
